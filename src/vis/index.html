<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Эволюция приматов</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.5.1/tabletop.min.js'></script>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="icon" type="image/png" href="favicon.png">
    <style>

    </style>
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter49480489 = new Ya.Metrika2({
                        id:49480489,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true,
                        webvisor:true
                    });
                } catch(e) { }
            });

            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/tag.js";

            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks2");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/49480489" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
</head>
<body>



<div id="axis">  </div>
<div id="plot">
    <svg id="chart"  height="8100"
         viewBox="0 0 200 8100"
         preserveAspectRatio="xMidYMin meet">
    </svg>
</div>
<div id="header">
    <img src="header_img.png" width="100" height="100" alt="Станислав Дробышевский">
    <h1>Эволюция приматов</h1>
    <p>«Эволюция приматов — более сложный процесс, чем многим кажется. Но, слава палеоприматологам, эволюция приматов изучена лучше, чем большинства других организмов.</p>
    <p>Имея тысячи находок, учитывая их географию и датировки, можно построить общую схему. Однако, насколько мне известно, доселе никто не озаботился этим всерьёз, поэтому пришлось делать всё самому.</p>
    <p>Итак, перед Вами — единственная в мире всеобщая эволюция приматов с точностью до подсемейств, местами по необходимости указаны и роды.</p>
    <p>По горизонтали время, справа —современные группы. Великий предок пургаториус сверху слева, мы — снизу справа»</p>
    <i>Станислав Дробышевский, антрополог и популяризатор науки</i>

</div>
<div id="footer">
    <p><a href="http://dianov.org">Иван Дианов</a> — дизайнер и руководитель</p>
    <p><a href="">Ольга Мохова </a> — программист</p>
    <p><a href="">Лёля Колесникова</a> перенесла данные из ПДФ</p>

</div>
<div id="legend"><img src="map.svg" alt="Легенда"></div>
<script>
    var myleaves=[];
    var publicSpreadsheetUrl = 'https://docs.google.com/spreadsheets/d/1rTL6r7exf_0SzZifpeW4532ggYn8KukEu1fzEKEex9s/edit?usp=sharing'

    function init() {
        Tabletop.init( { key: publicSpreadsheetUrl,
            callback: showInfo,
            debug:false,
            wanted:["Data"],
            simpleSheet: true } )
    }

    function showInfo(data, tabletop) {
        //alert('Successfully processed!')
        //console.log(data);
        /**/
        var data = data.map(processData);

        drawAnSVG()
        drawAnAxis()
        drawBegunok()
        initFilter()
        drawHierarchy(data)
        drawConnections(data)

        /**/

    }

    window.addEventListener('DOMContentLoaded', init)




   /* d3.tsv("Primat.tsv").then( function(rawdata) {

        var data = rawdata.map(processData);

        drawAnSVG()
        drawAnAxis()
        drawBegunok()
        initFilter()
        drawHierarchy(data)
        drawConnections(data)

    });*/

    function processData(d) {
        var processed = {
            id: d.id,
            mir: d.mirorder,
            order: d.order,
            suborder: d.suborder,
            hyporder:d.hyporder,
            infraorder:d.infraorder,
            parvorder:d.parvorder,
            superfamily:d.superfamily,
            family:d.family,
            subfamily:d.subfamily,
            genus:d.genus,
            location:d.location_ru,
            period_start:d.period_start,
            period_end:d.period_end,
            origin:d.origin,
            continent_id:d.continent_id
        }
        return processed;
    }

    function drawHierarchy(data) {
        ypos=30
        delta=0
        var myOrders=findOrders(data);
        myOrders.forEach(function (order) {
            drawEpicOrderName(order,"отряд");
            subOrders=getSubOrders(order,data)
            //console.log("suborders of ("+order+") = "+JSON.stringify(subOrders,null,2))
            subOrders.forEach(function (subOrder,o) {
                findIds(SubOrdersDataRoot[0],subOrder)
                if (subOrder) drawRect(myleaves,subOrder,"подотряд.","subOrder",o*10+6)
                hypOrders=getHypOrders(subOrder,data)
                //console.log("hypOrders of ("+order+"-"+subOrder+") = "+JSON.stringify(hypOrders,null,2))
                hypOrders.forEach(function (hypOrder,n) {
                    findIds(HypOrdersDataRoot[0],hypOrder)
                    if (hypOrder) drawRect(myleaves,hypOrder,"гипотряд.","hypOrder",n*100+o*10+5)
                    infraOrders=getInfraOrders(hypOrder,data)
                    //console.log("infraOrders of ("+order+"-"+subOrder+"-"+hypOrder+") = "+JSON.stringify(infraOrders,null,2))
                    infraOrders.forEach(function (infraOrder,m) {
                        findIds(infraOrdersDataRoot[0],infraOrder)
                        if (infraOrder) drawRect(myleaves,infraOrder,"инфраотряд.","infraOrder",m*1000+n*100+o*10+4)
                        parvOrders=getParvOrders(infraOrder,data)
                        parvOrders.forEach(function (parvOrder,l) {
                            findIds(parvOrdersDataRoot[0],parvOrder)
                            if (parvOrder) drawRect(myleaves,parvOrder,"парвотряд.","parvOrder",l*10000+m*1000+n*100+o*10+3)
                            superFamilys=getSuperFamilys(parvOrder,data)
                            superFamilys.forEach(function (superFamily,k ){
                                findIds(superFamilysDataRoot[0],superFamily)
                                if (superFamily) drawRect(myleaves,superFamily,"суперсем.","superfamily",k*100000+l*10000+m*1000+n*100+o*10+2)
                                familys=getFamilys(superFamily,data)
                                familys.forEach(function (family,j) {
                                    findIds(familysDataRoot[0],family);
                                    //console.log("leaves familys ="+ JSON.stringify(myleaves))
                                    drawRect(myleaves,family, "сем.","family",j*1000000+k*100000+l*10000+m*1000+n*100+o*10+1);
                                    subFamilys=getSubFamilys(family,data);
                                    //console.log("subFamilys of ("+order+"-"+subOrder+"-"+hypOrder+"-"+infraOrder+"-"+parvOrder+"-"+superFamily+"-"+family+")=" +JSON.stringify(subFamilys,null,2))
                                    subFamilys.forEach(function (subFamily) {
                                        findIds(subfamilysDataRoot[0],subFamily);
                                        //console.log("leaves subfam ="+ JSON.stringify(myleaves))
                                        drawBricks(myleaves, subFamily, familys);
                                    });
                                    if (family) resizeRect(family,j*1000000+k*100000+l*10000+m*1000+n*100+o*10+1);
                                })
                                if (superFamily) resizeRect(superFamily,k*100000+l*10000+m*1000+n*100+o*10+2)
                            })
                            if (parvOrder) resizeRect(parvOrder,l*10000+m*1000+n*100+o*10+3)
                        })
                        if (infraOrder) resizeRect(infraOrder,m*1000+n*100+o*10+4)
                    })
                    if (hypOrder) resizeRect(hypOrder,n*100+o*10+5)
                })
                if (subOrder) resizeRect(subOrder,o*10+6)
            })
        })
    }

    function drawConnections(data) {
        var g=svg.append("g").attr("class","connections")
        data.forEach(function (d) {
            if (d.origin) {
                var brickFrom=svg.select("rect#id"+d.origin+".brick")
                var brickTo=svg.select("rect#id"+d.id+".brick")
                if (brickFrom.node() && brickTo.node()) {
                    var xFrom = parseFloat(brickFrom.attr("x")) + parseFloat(brickFrom.attr("width")) - 0.5
                    var yFrom = parseFloat(brickFrom.attr("y")) + 3
                    var xTo = parseFloat(brickTo.attr("x"))
                    var yTo = parseFloat(brickTo.attr("y")) + 3

                    if (xFrom>xTo) xFrom=parseFloat(brickFrom.attr("x")) +  0.5

                    var lineGenerator = d3.line().curve(d3.curveStepBefore);

                    var points = [
                        [xFrom, yFrom],
                        [xTo, yTo]
                    ];

                    var pathData = lineGenerator(points); // connections with corners

                    var data1 = [{ //connections with curves
                        source: {
                            x: yFrom,
                            y: xFrom
                        },
                        target: {
                            x: yTo,
                            y: xTo
                        }
                    }, ];

                    var link = d3.linkHorizontal()
                        .x(function(d) {
                            return d.y;
                        })
                        .y(function(d) {
                            return d.x;
                        });

                    //g.append('path').attr('d', pathData);
                    g.selectAll(null).data(data1).enter().append("path").attr('d', link);
                }
            }
        })
    }

    function getLeafNodes(leafNodes, obj){
        if(obj.values){
            obj.values.forEach(function(child){getLeafNodes(leafNodes,child)});
        } else{
            leafNodes.push(obj);
        }
        myleaves=leafNodes;
    }

    function findIds(json,name){
        if(json.values){
            //console.log('WE ARE IN '+json.key)
            if(json.key==name)  {
                var leafNodes = [];
                getLeafNodes(leafNodes,json);
                //console.log("leafNodes = "+leafNodes.map(function(leafNode){ return leafNode.id; })); //Logs leaf node ids to the console
            } else {
                json.values.forEach(function(child){
                    findIds(child,name);
                });
            }
        }
        //else console.log("other leaf "+JSON.stringify(json,null,1));
        //console.log("leafNodes end = "+leafNodes); //Logs leaf node ids to the console
    }

    function findOrders(data) {
        var myOrdersData = d3.nest()
            .key(function (d) { return d.order })
            .entries(data);
        //console.log("orders = "+myOrdersData.map(function(node){ return node.key; }));
        var myOrders=myOrdersData.map(function(node){ return node.key; })
        return myOrders;
    }

    function drawAnSVG() {
        var chartDiv = document.getElementById("plot");
        ourWidth = chartDiv.clientWidth
        plotWidth=ourWidth-250
        console.log("w= "+ourWidth)
        svg = d3.select("svg");
        svg.attr("width", plotWidth)
            .attr("viewBox", "0 0 "+plotWidth+" 8100")
        g_axis=d3.select("#axis").append("svg")
            .attr("width",plotWidth)
            .attr("height",20)
            .append("g").attr("class","axis")
        g = svg.append("g").attr("class","taxons");
    }

    function drawAnAxis() {
        var width=plotWidth
        x = d3.scaleLinear()
            .domain([-70, 5])
            .range([20, width-100])

        var xAxis = d3.axisBottom(x)
        var xAxisPeriods=d3.axisTop(x)
        var periods=[];
        var pp;

        d3.tsv("Primat - Layers.tsv").then(function (data) { // make axis with periods from tsv
            data.forEach(function (d) {
                periods.push(d.date_start*(-1));
            });
            g_axis.append("g").attr("class", "axis axis--x")
                .call(xAxis.tickSize(1).tickSizeInner(1).tickSizeOuter(1) //ticks format
                    .tickValues(periods));

            g_pp=g_axis.append("g").attr("class","pretty_periods")
            periods.forEach(function (v,i,a) {
                if (i<a.length-1)
                g_pp.append("line")
                    .attr("x1",x(v))
                    .attr("x2",x(a[i+1]))
                    .attr("y1",0)
                    .attr("y2",0)
                    .attr("stroke-width",2)
                    .attr("stroke", () =>{
                        var color="yellow"
                        if (i%3==0) color="#DFDEDE"
                        if (i%3==1) color="#918F8F"
                        if (i%3==2) color="#BDBBBC"
                        return color
                    })
            })
            pp=data;
            return data;
        });

        var periodNames = ["мел","палеоцен", "эоцен", "олигоцен","миоцен","плиоцен","плейстоцен","голоцен"];
        g_axis.append("g").attr("class", "axis periods")
            .call(xAxisPeriods
                .tickValues([-70,-61,-44.95,-28.465,-14.1815,-3.5695,-0.90885,0])
                .tickFormat(function (d,i) {
                    return periodNames[i];
                })
                .tickPadding(5)
                .tickSize(0));

    }

    function drawBegunok() {
        height=10000
        var vertical = g_axis.append("path").attr("class", "trackLine");//add the mouse-tracking vertical line
        var vertical2 = svg.append("path").attr("class", "trackLine");//add the mouse-tracking vertical line
        var begunokG=g_axis.append("g").attr("id","begunok");
        var begunokRect=begunokG.append("rect");
        var begunokText= begunokG.append("text");

        d3.selectAll("svg").on("mousemove", function(){
            mousex = d3.mouse(this);
            d3.selectAll(".trackLine").style("display", null).attr("d", function () {
                var d = "M" + mousex[0] + "," + (height);
                d += " " + mousex[0] + "," + 10;
                return d;
            });
            begunokRect.attr("id","begunok").attr("y",-20)
                .attr( "x",function (d){return (mousex[0]-35)});

            var format = d3.format(".1f");
            var time=-x.invert(mousex[0]);
            //console.log(time);
            d3.tsv("Primat - Layers.tsv").then(function (data) { //
                data.forEach(function (d,i,a) {
                    if (i<a.length-1) {
                        //console.log(a[i].date_start +" " + time +" "+ a[i + 1].date_start);
                        if (a[i].date_start > time && a[i + 1].date_start <time) {
                            //console.log("период " + a[i].layer_ru + "  " + a[i].sublayer);
                            begunokText.text(a[i].sublayer + "  " + a[i].layer_ru)
                                .attr("x",function () {return (mousex[0]-30)})
                                .attr("y",-5);
                        }
                    }
                })
            })
            /*begunokText.text(format(x.invert(mousex[0])))
                .attr("x",function () {return (mousex[0]-20)})
                .attr("y",-5);*/
        })
        /*.on("mouseout", function(){ //hide the line
        mousex = d3.mouse(this);
        mousex = mousex[0] + 5;
        vertical.style("display", "none")});*/
    }

    function drawEpicOrderName(name,taxon){
        g.append("text")
            .attr("class","epicOrderName").text(taxon+" "+name)
            .attr("y",ypos+30)
            .attr("x",plotWidth/2-25)
        ypos=ypos+50;
    }

    d3.selection.prototype.last = function()
    { return d3.select(this.nodes()[this.size() - 1]);}

    function resizeRect(name,i) {
        name=name.replace(/[|(|)|]| |=|\?|\./g,"")
        ypos=g.selectAll("g").last().node().getBBox().y+g.selectAll("g").last().node().getBBox().height
        var rect= g.selectAll("g#"+name+i).last().select("rect");
        var text= g.selectAll("g#"+name+i).last().select("text");
        ///rect.clone(true).attr("stroke","red");
        var maxRightEdge=0
        var flaf=false
        g.selectAll("#" + name + i + " ~ g > rect.rec_fam").nodes().forEach(function (node) {
            flaf=true
            rightEdge=node.getBBox().x+node.getBBox().width
            if (rightEdge>maxRightEdge) {
                maxRightEdge = rightEdge
            }
        })

        if (rect.node()) {
            newheight = ypos - rect.node().getBBox().y+10+delta
            newwidth=rect.node().getBBox().width+10+delta*2
            newex=rect.node().getBBox().x-delta
            //console.log ("made resize "+name+" "+delta)
        }
        if (rect.classed("rec_invisible")) {
            //console.log("invis"+ name)
            newex=newex-delta*2
            newheight=newheight-delta
            newwidth=newwidth-delta
            }

            rect.attr("height", newheight)
                .attr("width", newwidth)
                .attr("x", newex)

            text.attr("x", newex)

       if (flaf) {
            maxWidth=maxRightEdge-rect.node().getBBox().x
            rect
                //.clone(true).attr("class","rec_fam rec_clone")
                .attr("width", maxWidth+10);
        }
            ypos = ypos + 20 + delta * 1.5
            delta = delta + 10

    }

    function drawRect(ids,name,prefix,taxon,i) {
        delta=0
        trimname=name.replace(/[|(|)|]| |=|\?|\./g,"")
        const max_period=d3.max(ids, function (d) {return +d.period_start})
        const min_period=d3.min(ids,function (d) {return +d.period_end})
        const height_of_taxon=ids.length;

        var emptySubFam=false, atLeastOneSubTaxon=false,  atLeastOneGen=false

        /*flag of empty subFamily*/
        if (taxon=="family")
        ids.forEach(function (id) {
            if (id.subfamily=="" && id.genus=="") emptySubFam=true /*so, we don't need a family rectangle*/
            if (id.subfamily) atLeastOneSubTaxon=true
            if (id.genus) atLeastOneGen=true
        })

        g1=g.append("g").attr("id",trimname+i).attr("class", taxon)

        if (emptySubFam==false || atLeastOneSubTaxon==true || atLeastOneGen==true) {

            g1.append("rect")
                .attr("class", "rec_fam")
                .attr("x", x(-1 * max_period) - 10)
                .attr("y", ypos)
                .attr("width", x((max_period)) - x((min_period)) + 10)
                .attr("height", height_of_taxon * 20 + 10)
                .attr("filter", "url(#dropshadow)")
            g1.append("text")
            //.attr("class","rec_fam")
                .attr("x", x(-1 * (max_period)) + 1)
                .attr("y", ypos)
                .attr("text-anchor", "start")
                .text(prefix + " " + name)
        }
        else { /*invisible rectangle*/
            g1.append("rect")
                .attr("class", "rec_fam rec_invisible")
                .attr("x", x(-1 * max_period) )
                .attr("y", ypos)
                .attr("width", x(max_period) - x(min_period)+1 )
                .attr("height", height_of_taxon * 20 )

        }
        ypos = ypos + 10
    }

    function drawBricks(bricks,fam) {

        const max_period = d3.max(bricks, function (d) {
            return +d.period_start
        })
        const min_period = d3.min(bricks, function (d) {
            return +d.period_end
        })
        const height_of_taxon = bricks.length;

        if (g1.selectAll("g:last-of-type").node())
            ypos = g1.select("g:last-of-type").node().getBBox().y + g1.select("g:last-of-type").node().getBBox().height
        else ypos = g1.node().getBBox().y


        g2 = g1.append("g").attr("id", fam)
        var emptyGen=false, atLeastOneSubTaxon=false, atLeastOneGen=false, greenRec=false
        var firstLocation=bricks[0].location, sameGens=false, locations="("+firstLocation
        var nameOfUnionBrick
        /*flag of empty genus etc*/
        i = bricks.length - 1;

        while (i >= 0) {
            /*if (review[index] === 'a') {
                review.splice(index, 1);*/

        //bricks.forEach(function (brick,i,object) {
            //console.log (i+ " " + bricks[i].id)
            if (bricks[i].genus=="") emptyGen=true /*so, we don't need a subfamily rectangle*/
            if (bricks[i].subfamily) atLeastOneSubTaxon=true
            if (bricks[i].genus) atLeastOneGen=true
            /*if (i>0 && brick.genus==bricks[0].genus && brick.period_start==bricks[0].period_start && brick.period_end==bricks[0].period_end) {
                sameGens=true
                locations=locations+", "+brick.location
                if (brick.family) nameOfUnionBrick="сем. "+brick.family
                if (brick.subfamily) nameOfUnionBrick="подсем. "+brick.subfamily
                if (brick.genus) nameOfUnionBrick=brick.genus
            }
            else sameGens=false*/
            /**/
            if (i>0 && bricks[i-1].period_start==bricks[i].period_start && bricks[i-1].period_end==bricks[i].period_end && bricks[i-1].genus==bricks[i].genus){
                locations=bricks[i].location+", "+bricks[i-1].location
                bricks[i-1].location=locations
                bricks[i-1].continent_id="mix"
                bricks.splice(i,1)
            }
            //else if (i>0) console.log("no "+bricks[i-1].id+" "+bricks[i].id)
            sameGens=false
            /**/
        //})


            i -= 1;
        }
        locations=locations+")"

        if (atLeastOneGen==true && bricks[0].subfamily) {
        g2.append("rect")
            .attr("class", "rec_subfam")
            .attr("x", x(-1 * max_period) - 10)
            .attr("y", ypos + 20)
            .attr("width", x((max_period)) - x((min_period)) + 20)
            .attr("height", height_of_taxon * 20)
            .attr("filter", "url(#dropshadow)")
        g2.append("text")
        //.attr("class","rec_fam")
            .attr("x", x(-1 * (max_period))-10 )
            .attr("y", ypos + 20)
            .attr("text-anchor", "start")
            .text("подсем. " + fam)
            greenRec=true
            delta=10
        }

        if (sameGens==true){
            console.log(bricks[0].id+" "+nameOfUnionBrick+" locations=",locations)
            drawUnionBrick(nameOfUnionBrick, locations,ypos,bricks[0])
           // drawUsualBricks(bricks,ypos,atLeastOneGen,atLeastOneSubTaxon,greenRec)
        }
        else drawUsualBricks(bricks,ypos,atLeastOneGen,atLeastOneSubTaxon,greenRec)

    }

    function getColorOfTheBrick(continent){
        var color
        switch(continent) {
            case 'africa':
                color="#04c4d6"; break;
            case 'europe':
                color="#bcde05"; break;
            case 'asia':
                color="#3773ed"; break;
            case 'n_america':
                color="#ff0000"; break;
            case 's_america':
                color="#ff8a00"; break;
            case 'oceania':
                color="#c061c0"; break;
            default:
            color="#777"; break;
        }
        return color
    }

    function drawUsualBricks(bricks,ypos,atLeastOneGen,atLeastOneSubTaxon,greenRec) {
        g2.selectAll("rect.brick").data(bricks).enter().append("rect")
            .attr("class","brick") //create lines of period
            .attr("id", (d)=>"id"+d.id)
        //.on ("click",handleGenusClick)
            .attr("rx", 3)
            .attr("ry", 3)
            .attr("x", (d) => {if (!d.period_start) console.log("alert! no period start! id="+d.id);return x(-1 * d.period_start);})
            .attr("y",(d,i)=>ypos+i*20+32)
            .attr("width", function (d) {
                wid = x(d.period_start) - x(d.period_end); //calculate length of line
                if (wid<5) wid=5;
                return wid;
            })
            .attr("height", 5)
            .attr("stroke", "none")
            .attr("fill", "#ff8a00")
            .attr("fill", (d)=>getColorOfTheBrick(d.continent_id));

        var desireLength=30;//length of text labels

        g2.selectAll('text.genus').data(bricks).enter().append("text")//create signs for lines
            .attr("class","genus")
            .text(function(d){
                if (d.genus=="—" || d.genus=="") { // oh really, no genus?
                    if (d.subfamily=="—" || d.subfamily=="") {
                        if (atLeastOneGen==true)
                        fullText=d.id+" "+" ("+d.location+")"; //завершающая пустышка семейства
                        else
                            fullText=d.id+" "+"сем. "+d.family+" ("+d.location+")";
                    }
                    else {
                        if (atLeastOneSubTaxon == true && greenRec)
                            fullText=d.id + " " + " (" + d.location + ")";//завершающая пустышка подсемейства
                        else
                        fullText=d.id + " " + "подсем." + d.subfamily + " (" + d.location + ")";
                    }
                }
                else
                    fullText=d.id+" "+d.genus+" ("+d.location+")"
            return fullText //full name of the brick
            })
            .attr ("data-fullName", function (){return d3.select(this).text()}) //remember our full name in attr
            .text(function () {
                if (this.innerHTML.length>desireLength) dots="..."; else dots=""
                return d3.select(this).text().substring(0,desireLength)+dots // trim long name
            })
            .attr("x", function (d) {
                return x(-1*d.period_start);
            })
            .attr("y", function (d, j) {
                return ypos+j*20 +30 ;
            })
            .on('mouseover', function(){
                d3.select(this).text(function () {
                    return this.getAttribute("data-fullName") //show full name
                });
            })
            .on ("mouseout", function () {
                d3.select(this).text(function () {
                    if (this.innerHTML.length>desireLength) dots="..."; else dots=""
                    return d3.select(this).text().substring(0, desireLength) + dots//back trim name
                })
            })
        ;
    }

    function drawUnionBrick(nameofUnionBrick, locations,ypos,d) {

        g2.append("rect").attr("class","brick") //create lines of period
        //.on ("click",handleGenusClick)
            .attr("rx", 3)
            .attr("ry", 3)
            .attr("x", function(){if (!d.period_start) console.log("alert! no period start! id="+d.id);return x(-1 * d.period_start);})
            .attr("y",ypos+32)
            .attr("width", function(){
                wid = x(d.period_start) - x(d.period_end); //calculate length of line
                if (wid<5) wid=5;
                return wid;
            })
            .attr("height", 5)
            .attr("stroke", "none")
            .attr("fill", "#ff8a00");

        g2.append("text")//create signs for lines
            .attr("class","genus")
            .text(()=>"! "+d.id+" "+nameofUnionBrick+" "+locations)
            .attr("x", function () {
                return x(-1*d.period_start);
            })
            .attr("y", ypos+30);
    }

    function getSubOrders(order,data) {
        OrdersData=data.filter(function (d) {return d.order===order})
        SubOrdersDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.suborder})
            .entries(OrdersData)
        var SubOrdersData= d3.nest()
            .key(function (d) {return d.suborder})
            .entries(OrdersData)
        var subOrders=SubOrdersData.map(function(node){ return node.key; })
        return subOrders
    }

    function getHypOrders(subOrder,data) {
        subOrdersData=OrdersData.filter(function (d) {return d.suborder===subOrder})
        HypOrdersDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.hyporder})
            .entries(subOrdersData)
        var HypOrdersData= d3.nest()
            .key(function (d) {return d.hyporder})
            .entries(subOrdersData)
        var hypOrders=HypOrdersData.map(function(node){ return node.key; })
        return hypOrders
    }

    function getInfraOrders(hypOrder,data) {
        hypOrdersData=subOrdersData.filter(function (d) {return d.hyporder===hypOrder})
        infraOrdersDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.infraorder})
            .entries(hypOrdersData)
        var infraOrdersData= d3.nest()
            .key(function (d) {return d.infraorder})
            .entries(hypOrdersData)
        var infraOrders=infraOrdersData.map(function(node){ return node.key; })
        return infraOrders
    }

    function getParvOrders(infraOrder,data) {
        infraOrdersData=hypOrdersData.filter(function (d) {return d.infraorder===infraOrder})
        parvOrdersDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.parvorder})
            .entries(infraOrdersData)
        var parvOrdersData= d3.nest()
            .key(function (d) {return d.parvorder})
            .entries(infraOrdersData)
        var parvOrders=parvOrdersData.map(function(node){ return node.key; })
        return parvOrders
    }

    function getSuperFamilys(parvOrder,data) {
        parvOrdersData=infraOrdersData.filter(function (d) {return d.parvorder===parvOrder})
        superFamilysDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.superfamily})
            .entries(parvOrdersData)
        var superFamilysData= d3.nest()
            .key(function (d) {return d.superfamily})
            .entries(parvOrdersData)
        var superFamilys=superFamilysData.map(function(node){ return node.key; })
        return superFamilys
    }

    function getFamilys(superFamily,data) {
        superFamilysData=parvOrdersData.filter(function (d) {return d.superfamily===superFamily})
        familysDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.family})
            .entries(superFamilysData)
        familysData= d3.nest()
            .key(function (d) {return d.family})
            .entries(superFamilysData)
        var familys=familysData.map(function(node){ return node.key; })
        return familys
    }

    function getSubFamilys(family,data) {
        familysData=superFamilysData.filter(function (d) {return d.family===family})
        subfamilysDataRoot= d3.nest()
            .key(function (d) { return "root" })
            .key(function (d) {return d.subfamily})
            .entries(familysData)
        subfamilysData= d3.nest()
            .key(function (d) {return d.subfamily})
            .entries(familysData)
        //console.log("JJ="+JSON.stringify(subfamilysData[0],null,2))
        var subFamilys=subfamilysData.map(function(node){ return node.key; })
        return subFamilys
    }

    function initFilter(){
        /* For the drop shadow filter*/
        var defs = svg.append("defs");

        var filter = defs.append("filter")
            .attr("id", "dropshadow")
            .attr("height", "130%");

        filter.append("feGaussianBlur")
            .attr("in", "SourceAlpha")
            .attr("stdDeviation", 4)
            .attr("result", "blur");
        filter.append("feOffset")
            .attr("in", "blur")
            .attr("dx", 2)
            .attr("dy", 2)
            .attr("result", "offsetBlur");

        var feMerge = filter.append("feMerge");

        feMerge.append("feMergeNode")
            .attr("in", "offsetBlur")
        feMerge.append("feMergeNode")
            .attr("in", "SourceGraphic");
    }

    $(window).scroll(function() {
        if ($(this).scrollTop() /*> $('#axis').outerHeight(includeMargin=true)*/){
            $('#axis').addClass("sticky");
            $('#plot').addClass("sticky_plot");
            //set horizontal position of fixed axis div
            //var leftpos = ($(window).width() - $('#axis').width())/2;
            //$('#axis').css("left", leftpos);
        }
        else{
            $('#axis').removeClass("sticky");
            $('#plot').removeClass("sticky_plot");
        }
    });

</script>
</body>
</html>
